; Generated by c86 (BYU-NASM) 5.1 (beta) from lab8app.i
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
L_lab8app_3:
	DB	"got next command",0xD,0xA,0
	ALIGN	2
setReceivedCommand_handler:
	; >>>>> Line:	74
	; >>>>> void setReceivedCommand_handler(void){ 
	jmp	L_lab8app_4
L_lab8app_5:
	; >>>>> Line:	75
	; >>>>> printString("got next command\r\n"); 
	mov	ax, L_lab8app_3
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	76
	; >>>>> YKSemPost(nextCommandPtr); 
	push	word [nextCommandPtr]
	call	YKSemPost
	add	sp, 2
	mov	sp, bp
	pop	bp
	ret
L_lab8app_4:
	push	bp
	mov	bp, sp
	jmp	L_lab8app_5
L_lab8app_7:
	DB	"not enough pieces",0xD,0xA,0
	ALIGN	2
gotNewPiece_handler:
	; >>>>> Line:	79
	; >>>>> void gotNewPiece_handler(void){ 
	jmp	L_lab8app_8
L_lab8app_9:
	; >>>>> Line:	80
	; >>>>> if (availablePieces <= 0){ 
	cmp	word [L_lab8app_1], 0
	jg	L_lab8app_10
	; >>>>> Line:	81
	; >>>>> printString("not enough pieces\r\n"); 
	mov	ax, L_lab8app_7
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	82
	; >>>>> exit (0xff); 
	mov	al, 255
	push	ax
	call	exit
	add	sp, 2
L_lab8app_10:
	; >>>>> Line:	84
	; >>>>> availablePieces--; 
	dec	word [L_lab8app_1]
	; >>>>> Line:	85
	; >>>>> pieces[availablePieces].id = NewPieceID; 
	mov	ax, word [L_lab8app_1]
	mov	cx, 3
	shl	ax, cl
	mov	si, ax
	add	si, pieces
	mov	ax, word [NewPieceID]
	mov	word [si], ax
	; >>>>> Line:	86
	; >>>>> pieces[availablePieces].type = NewPieceType; 
	mov	ax, word [L_lab8app_1]
	mov	cx, 3
	shl	ax, cl
	add	ax, pieces
	mov	si, ax
	add	si, 2
	mov	ax, word [NewPieceType]
	mov	word [si], ax
	; >>>>> Line:	87
	; >>>>> = action; 
	mov	ax, word [L_lab8app_1]
	mov	cx, 3
	shl	ax, cl
	add	ax, pieces
	mov	si, ax
	add	si, 4
	mov	ax, word [NewPieceOrientation]
	mov	word [si], ax
	; >>>>> Line:	88
	; >>>>> pieces[availablePieces].column = NewPieceColumn; 
	mov	ax, word [L_lab8app_1]
	mov	cx, 3
	shl	ax, cl
	add	ax, pieces
	mov	si, ax
	add	si, 6
	mov	ax, word [NewPieceColumn]
	mov	word [si], ax
	; >>>>> Line:	90
	; >>>>> YKQPost(pieceQPtr, (void*) &(pieces[availablePieces])); 
	mov	ax, word [L_lab8app_1]
	mov	cx, 3
	shl	ax, cl
	add	ax, pieces
	push	ax
	push	word [pieceQPtr]
	call	YKQPost
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_lab8app_8:
	push	bp
	mov	bp, sp
	jmp	L_lab8app_9
L_lab8app_12:
	DB	"GAME OVER!",0
	ALIGN	2
setGameOver:
	; >>>>> Line:	93
	; >>>>> void setGameOver(void){ 
	jmp	L_lab8app_13
L_lab8app_14:
	; >>>>> Line:	94
	; >>>>> printString("GAME OVER!"); 
	mov	ax, L_lab8app_12
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	95
	; >>>>> exit(0xff); 
	mov	al, 255
	push	ax
	call	exit
	add	sp, 2
	mov	sp, bp
	pop	bp
	ret
L_lab8app_13:
	push	bp
	mov	bp, sp
	jmp	L_lab8app_14
L_lab8app_16:
	DB	"not enough moves",0xD,0xA,0
	ALIGN	2
createMove:
	; >>>>> Line:	100
	; >>>>> void createMove(unsigned idOfPiece, int action){ 
	jmp	L_lab8app_17
L_lab8app_18:
	; >>>>> Line:	101
	; >>>>> if (availableMoves <= 0){ 
	cmp	word [L_lab8app_2], 0
	jg	L_lab8app_19
	; >>>>> Line:	102
	; >>>>> printString("not enough moves\r\n"); 
	mov	ax, L_lab8app_16
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	103
	; >>>>> exit(0xff); 
	mov	al, 255
	push	ax
	call	exit
	add	sp, 2
L_lab8app_19:
	; >>>>> Line:	105
	; >>>>> availableMoves--; 
	dec	word [L_lab8app_2]
	; >>>>> Line:	106
	; >>>>> moves[availableMoves].idOfPiece = idOfPiece; 
	mov	ax, word [L_lab8app_2]
	shl	ax, 1
	shl	ax, 1
	add	ax, moves
	mov	si, ax
	add	si, 2
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	107
	; >>>>> moves[availableMoves].action = action; 
	mov	ax, word [L_lab8app_2]
	shl	ax, 1
	shl	ax, 1
	mov	si, ax
	add	si, moves
	mov	ax, word [bp+6]
	mov	word [si], ax
	; >>>>> Line:	109
	; >>>>> YKQPost(moveQPtr, (void*) &(moves[availableMoves])); 
	mov	ax, word [L_lab8app_2]
	shl	ax, 1
	shl	ax, 1
	add	ax, moves
	push	ax
	push	word [moveQPtr]
	call	YKQPost
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_lab8app_17:
	push	bp
	mov	bp, sp
	jmp	L_lab8app_18
L_lab8app_22:
	DB	"got flat",0xD,0xA,0
L_lab8app_21:
	DB	"got Corner",0xD,0xA,0
	ALIGN	2
placementTask:
	; >>>>> Line:	114
	; >>>>> void placementTask(){  
	jmp	L_lab8app_23
L_lab8app_24:
	; >>>>> Line:	117
	; >>>>> while(1){ 
	jmp	L_lab8app_26
L_lab8app_25:
	; >>>>> Line:	118
	; >>>>> temp = (PIECE*)YKQPend(pieceQPtr);  
	push	word [pieceQPtr]
	call	YKQPend
	add	sp, 2
	mov	word [bp-2], ax
	; >>>>> Line:	119
	; >>>>> availablePieces++; 
	inc	word [L_lab8app_1]
	; >>>>> Line:	121
	; >>>>> id = temp->id; 
	mov	si, word [bp-2]
	mov	ax, word [si]
	mov	word [bp-4], ax
	; >>>>> Line:	122
	; >>>>> type = temp->type; 
	mov	si, word [bp-2]
	add	si, 2
	mov	ax, word [si]
	mov	word [bp-10], ax
	; >>>>> Line:	123
	; >>>>> orient = temp->orientation; 
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	mov	word [bp-8], ax
	; >>>>> Line:	124
	; >>>>> col = temp->column; 
	mov	si, word [bp-2]
	add	si, 6
	mov	ax, word [si]
	mov	word [bp-6], ax
	; >>>>> Line:	127
	; >>>>> if (type == 0){ 
	mov	ax, word [bp-10]
	test	ax, ax
	jne	L_lab8app_28
	; >>>>> Line:	128
	; >>>>> printString("got Corner\r\n"); 
	mov	ax, L_lab8app_21
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	129
	; >>>>> createMove(id, 0); 
	xor	ax, ax
	push	ax
	push	word [bp-4]
	call	createMove
	add	sp, 4
	jmp	L_lab8app_29
L_lab8app_28:
	; >>>>> Line:	132
	; >>>>> printString("got flat\r\n" 
	mov	ax, L_lab8app_22
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	133
	; >>>>> createMove(id, 1); 
	mov	ax, 1
	push	ax
	push	word [bp-4]
	call	createMove
	add	sp, 4
L_lab8app_29:
L_lab8app_26:
	jmp	L_lab8app_25
L_lab8app_27:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_23:
	push	bp
	mov	bp, sp
	sub	sp, 10
	jmp	L_lab8app_24
L_lab8app_34:
	DB	"rotate right",0xD,0xA,0
L_lab8app_33:
	DB	"rotate left",0xD,0xA,0
L_lab8app_32:
	DB	"go right",0xD,0xA,0
L_lab8app_31:
	DB	"go left",0xD,0xA,0
	ALIGN	2
communicationTask:
	; >>>>> Line:	138
	; >>>>> void communicationTask(){  
	jmp	L_lab8app_35
L_lab8app_36:
	; >>>>> Line:	140
	; >>>>> while(1){ 
	jmp	L_lab8app_38
L_lab8app_37:
	; >>>>> Line:	141
	; >>>>> temp = (MOVE*)YKQPend(moveQPtr);  
	push	word [moveQPtr]
	call	YKQPend
	add	sp, 2
	mov	word [bp-2], ax
	; >>>>> Line:	142
	; >>>>> availableMoves++; 
	inc	word [L_lab8app_2]
	; >>>>> Line:	144
	; >>>>> if (temp->action == 0){ 
	mov	si, word [bp-2]
	mov	ax, word [si]
	test	ax, ax
	jne	L_lab8app_40
	; >>>>> Line:	145
	; >>>>> printString("go left\r\n"); 
	mov	ax, L_lab8app_31
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	146
	; >>>>> SlidePiece(temp->idOfPiece, 0); 
	xor	ax, ax
	push	ax
	mov	si, word [bp-2]
	add	si, 2
	push	word [si]
	call	SlidePiece
	add	sp, 4
	jmp	L_lab8app_41
L_lab8app_40:
	; >>>>> Line:	147
	; >>>>> } else if (temp->action == 1){ 
	mov	si, word [bp-2]
	cmp	word [si], 1
	jne	L_lab8app_42
	; >>>>> Line:	148
	; >>>>> printString("go right\r\n"); 
	mov	ax, L_lab8app_32
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	149
	; >>>>> SlidePiece(temp->idOfPiece, 1); 
	mov	ax, 1
	push	ax
	mov	si, word [bp-2]
	add	si, 2
	push	word [si]
	call	SlidePiece
	add	sp, 4
	jmp	L_lab8app_43
L_lab8app_42:
	; >>>>> Line:	150
	; >>>>> } else if (temp->action == 2){ 
	mov	si, word [bp-2]
	cmp	word [si], 2
	jne	L_lab8app_44
	; >>>>> Line:	151
	; >>>>> printString("rotate left\r\n"); 
	mov	ax, L_lab8app_33
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	152
	; >>>>>  
	mov	ax, 1
	push	ax
	mov	si, word [bp-2]
	add	si, 2
	push	word [si]
	call	RotatePiece
	add	sp, 4
	jmp	L_lab8app_45
L_lab8app_44:
	; >>>>> Line:	154
	; >>>>> printString("rotate right\r\n"); 
	mov	ax, L_lab8app_34
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	155
	; >>>>> RotatePiece(temp->idOfPiece, 0); 
	xor	ax, ax
	push	ax
	mov	si, word [bp-2]
	add	si, 2
	push	word [si]
	call	RotatePiece
	add	sp, 4
L_lab8app_45:
L_lab8app_43:
L_lab8app_41:
	; >>>>> Line:	157
	; >>>>> YKSemPend(nextCommandPtr); 
	push	word [nextCommandPtr]
	call	YKSemPend
	add	sp, 2
L_lab8app_38:
	jmp	L_lab8app_37
L_lab8app_39:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_35:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_lab8app_36
L_lab8app_53:
	DB	"% >",0xD,0xA,0
L_lab8app_52:
	DB	", CPU: ",0
L_lab8app_51:
	DB	"<CS: ",0
L_lab8app_50:
	DB	"after delay",0xD,0xA,0
L_lab8app_49:
	DB	"before delay",0xD,0xA,0
L_lab8app_48:
	DB	"Determining CPU capacity",0xD,0xA,0
L_lab8app_47:
	DB	"Welcome to the YAK kernel",0xD,0xA,0
	ALIGN	2
statisticsTask:
	; >>>>> Line:	161
	; >>>>> void statisticsTask(){  
	jmp	L_lab8app_54
L_lab8app_55:
	; >>>>> Line:	165
	; >>>>> YKDelayTask(1); 
	mov	ax, 1
	push	ax
	call	YKDelayTask
	add	sp, 2
	; >>>>> Line:	166
	; >>>>> printString("Welcome to the YAK kernel\r\n"); 
	mov	ax, L_lab8app_47
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	167
	; >>>>> printString("Determining CPU capacity\r\n"); 
	mov	ax, L_lab8app_48
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	168
	; >>>>> YKDelayTask(1); 
	mov	ax, 1
	push	ax
	call	YKDelayTask
	add	sp, 2
	; >>>>> Line:	169
	; >>>>> YKIdleCount = 0; 
	mov	word [YKIdleCount], 0
	; >>>>> Line:	170
	; >>>>> YKDelayTask(5); 
	mov	ax, 5
	push	ax
	call	YKDelayTask
	add	sp, 2
	; >>>>> Line:	171
	; >>>>> max = YKIdleCount / 25; 
	mov	ax, word [YKIdleCount]
	xor	dx, dx
	mov	cx, 25
	div	cx
	mov	word [bp-4], ax
	; >>>>> Line:	172
	; >>>>> YKIdleCount = 0 
	mov	word [YKIdleCount], 0
	; >>>>> Line:	175
	; >>>>> StartSimptris(); 
	call	StartSimptris
	; >>>>> Line:	178
	; >>>>> YKNewTask(placementTask, (void*) &placementTaskStk[512], 20); 
	mov	al, 20
	push	ax
	mov	ax, (placementTaskStk+1024)
	push	ax
	mov	ax, placementTask
	push	ax
	call	YKNewTask
	add	sp, 6
	; >>>>> Line:	179
	; >>>>> YKNewTask(communicationTask, (void*) &communicationTaskStk[512], 10); 
	mov	al, 10
	push	ax
	mov	ax, (communicationTaskStk+1024)
	push	ax
	mov	ax, communicationTask
	push	ax
	call	YKNewTask
	add	sp, 6
	; >>>>> Line:	182
	; >>>>> while(1){ 
	jmp	L_lab8app_57
L_lab8app_56:
	; >>>>> Line:	183
	; >>>>> printString("before delay\r\n"); 
	mov	ax, L_lab8app_49
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	184
	; >>>>> YKDelayTask(20); 
	mov	ax, 20
	push	ax
	call	YKDelayTask
	add	sp, 2
	; >>>>> Line:	185
	; >>>>> printString("after delay\r\n"); 
	mov	ax, L_lab8app_50
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	187
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	188
	; >>>>> switchCount = YKCtxSwCount; 
	mov	ax, word [YKCtxSwCount]
	mov	word [bp-6], ax
	; >>>>> Line:	189
	; >>>>> idleCount = YKIdleCount; 
	mov	ax, word [YKIdleCount]
	mov	word [bp-2], ax
	; >>>>> Line:	190
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	192
	; >>>>> printString("<CS: "); 
	mov	ax, L_lab8app_51
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	193
	; >>>>> printInt((int)switchCount); 
	push	word [bp-6]
	call	printInt
	add	sp, 2
	; >>>>> Line:	194
	; >>>>> printString(", 
	mov	ax, L_lab8app_52
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	195
	; >>>>> tmp = (int) (idleCount/max); 
	mov	ax, word [bp-2]
	xor	dx, dx
	div	word [bp-4]
	mov	word [bp-8], ax
	; >>>>> Line:	196
	; >>>>> printInt(100-tmp); 
	mov	ax, 100
	sub	ax, word [bp-8]
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	197
	; >>>>> printString("% >\r\n"); 
	mov	ax, L_lab8app_53
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	199
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	200
	; >>>>> YKCtxSwCount = 0; 
	mov	word [YKCtxSwCount], 0
	; >>>>> Line:	201
	; >>>>> YKIdleCount = 0; 
	mov	word [YKIdleCount], 0
	; >>>>> Line:	202
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
L_lab8app_57:
	jmp	L_lab8app_56
L_lab8app_58:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_54:
	push	bp
	mov	bp, sp
	sub	sp, 8
	jmp	L_lab8app_55
	ALIGN	2
main:
	; >>>>> Line:	211
	; >>>>> { 
	jmp	L_lab8app_60
L_lab8app_61:
	; >>>>> Line:	212
	; >>>>> YKInitialize(); 
	call	YKInitialize
	; >>>>> Line:	215
	; >>>>> YKNewTask(statisticsTask, (void *) &statisticsTaskStk[512], 30); 
	mov	al, 30
	push	ax
	mov	ax, (statisticsTaskStk+1024)
	push	ax
	mov	ax, statisticsTask
	push	ax
	call	YKNewTask
	add	sp, 6
	; >>>>> Line:	216
	; >>>>> nextCommandPtr = YKSemCreate(0); 
	xor	ax, ax
	push	ax
	call	YKSemCreate
	add	sp, 2
	mov	word [nextCommandPtr], ax
	; >>>>> Line:	217
	; >>>>> pieceQPtr = YKQCreate(pieceQ, 10); 
	mov	ax, 10
	push	ax
	mov	ax, pieceQ
	push	ax
	call	YKQCreate
	add	sp, 4
	mov	word [pieceQPtr], ax
	; >>>>> Line:	218
	; >>>>> moveQPtr = YKQCreate(moveQ, 10); 
	mov	ax, 10
	push	ax
	mov	ax, moveQ
	push	ax
	call	YKQCreate
	add	sp, 4
	mov	word [moveQPtr], ax
	; >>>>> Line:	219
	; >>>>> availablePieces = 10; 
	mov	word [L_lab8app_1], 10
	; >>>>> Line:	220
	; >>>>> availableMoves = 10; 
	mov	word [L_lab8app_2], 10
	; >>>>> Line:	221
	; >>>>> S 
	mov	ax, 37428
	xor	dx, dx
	push	dx
	push	ax
	call	SeedSimptris
	add	sp, 4
	; >>>>> Line:	224
	; >>>>> YKRun(); 
	call	YKRun
	mov	sp, bp
	pop	bp
	ret
L_lab8app_60:
	push	bp
	mov	bp, sp
	jmp	L_lab8app_61
	ALIGN	2
nextCommandPtr:
	TIMES	2 db 0
pieceQ:
	TIMES	20 db 0
pieceQPtr:
	TIMES	2 db 0
moveQ:
	TIMES	20 db 0
moveQPtr:
	TIMES	2 db 0
placementTaskStk:
	TIMES	1024 db 0
communicationTaskStk:
	TIMES	1024 db 0
statisticsTaskStk:
	TIMES	1024 db 0
pieces:
	TIMES	80 db 0
L_lab8app_1:
	TIMES	2 db 0
moves:
	TIMES	40 db 0
L_lab8app_2:
	TIMES	2 db 0
